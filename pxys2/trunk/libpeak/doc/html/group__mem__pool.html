<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PEAK Library: Memory pool</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>Memory pool</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b></b></dt><dd>Memory pool allocator for objects of same size. This interface offers an allocator <a class="el" href="group__mem__pool.html#ga9">peak_mem_pool_new()</a> which is O(1) except in some rare cases when the pool is growing (at worst log2(<code>n</code>) times for <code>n</code> allocations). However, if you know its size in advance, you can precise it in the <code>peak_mem_pool</code> creation method <a class="el" href="group__mem__pool.html#ga7">peak_mem_pool_create()</a>. You can create as many memory pools you want as interface and implementation are object oriented (like most of peak stuffs). </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="ga0" doxytag="mem_pool::peak_mem_pool" ></a>
typedef __peak_mem_pool *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque mem_pool pointer type. <br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__pool.html#ga1">peak_mem_pool_create</a> (int object_size, int log_size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mem_pool object.  <a href="#ga1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__pool.html#ga2">peak_mem_pool_new</a> (<a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a> pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an object in constant time.  <a href="#ga2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__pool.html#ga3">peak_mem_pool_delete</a> (<a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a> pool, void *ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocate an object in constant time.  <a href="#ga3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__pool.html#ga4">peak_mem_pool_get_used_count</a> (<a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a> pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics: get used pointers count.  <a href="#ga4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__pool.html#ga5">peak_mem_pool_get_free_count</a> (<a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a> pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics: get free pointers count.  <a href="#ga5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__mem__pool.html#ga6">peak_mem_pool_get_size</a> (<a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a> pool)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics: get total pointers count.  <a href="#ga6"></a><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga1" doxytag="mem_pool.h::peak_mem_pool_create" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a> peak_mem_pool_create </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>object_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>log_size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a mem_pool object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>object_size</em>&nbsp;</td><td>Size of each object in the memory pool. This cannot be changed later. It's commonly <code>sizeof</code>(struct your_object_structure). </td></tr>
    <tr><td valign=top><em>log_size</em>&nbsp;</td><td>Log base 2 of the initial size of memory pool. Use 0 if you don't know, it will use the minimum.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A new allocated <code>peak_mem_pool</code> reference or <code>NULL</code> if the operation failed. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="mem_pool.h::peak_mem_pool_delete" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void peak_mem_pool_delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>pool</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>ptr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocate an object in constant time. 
<p>
This method is guaranted O(1) but in rare case it might free a chunk of memory.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pool</em>&nbsp;</td><td>The memory pool reference. </td></tr>
    <tr><td valign=top><em>ptr</em>&nbsp;</td><td>The pointer to a memory space to deallocate. This pointer must have been previously provided by <a class="el" href="group__mem__pool.html#ga9">peak_mem_pool_new()</a>. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="mem_pool.h::peak_mem_pool_get_free_count" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int peak_mem_pool_get_free_count </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Statistics: get free pointers count. 
<p>
This method is guaranted O(1).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pool</em>&nbsp;</td><td>The memory pool reference.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of pointer currently unused (free for allocation). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="mem_pool.h::peak_mem_pool_get_size" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int peak_mem_pool_get_size </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Statistics: get total pointers count. 
<p>
This method is guaranted O(1).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pool</em>&nbsp;</td><td>The memory pool reference.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Size of all pointers really allocated by the memory pool. It grows automatically when no more free pointers are available, and also might eventually decrease if needed. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="mem_pool.h::peak_mem_pool_get_used_count" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int peak_mem_pool_get_used_count </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Statistics: get used pointers count. 
<p>
This method is guaranted O(1).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pool</em>&nbsp;</td><td>The memory pool reference.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of pointer currently in use (allocated). </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="mem_pool.h::peak_mem_pool_new" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* peak_mem_pool_new </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__mem__pool.html#ga0">peak_mem_pool</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pool</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocate an object in constant time. 
<p>
This method is guaranted O(1) almost all the time, but in rare case it might allocate a chunk of memory to let the memory pool grow.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>pool</em>&nbsp;</td><td>The memory pool reference.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to <em>object_size</em> bytes of memory. The allocated space is suitably aligned for storage of any common type of object. Please consult libpeak's compile time options to enable storage of special object like Altivec's vector (which needs 16-bytes align). Also please note the returned memory is NOT normally initialized to zero bytes. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jan 17 21:41:54 2004 for the PEAK Library by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0" > 
</a></small>&nbsp; &nbsp; <a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=98146&amp;type=1" width="88" height="31" align="middle" border="0" alt="SourceForge.net Logo" /></a></address>
</body>
</html>


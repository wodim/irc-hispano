<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>PEAK Library: Thread&apos;s synchronization</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>Thread's synchronization<br>
<small>
[<a class="el" href="group__task.html">Task</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<dl compact><dt><b></b></dt><dd>A task, in the PEAK's context, might process events in parallel, with the help of kernel threads (pthread(3)).</dd></dl>
<dl compact><dt><b></b></dt><dd>The PEAK library provides a set of functions for kernel threads synchronization within a task. If the task has only one thread to process events, these functions do nothing. Otherwise, they are prefered to more low level primitives as some optimizations can be done within a task. Be careful if you need to synchronize with other threads which are not related to a PEAK's task (eg. another thread in your program created explicitely): in that case you need more general primitives.</dd></dl>
<dl compact><dt><b></b></dt><dd>When in doubt, for example if you are not very familiar with threads synchronization primitives like mutex, conditions or semaphores, you have always the choice to configure your PEAK's task to not use more than one thread (see <a class="el" href="group__task__common.html#ga17">peak_task_set_info()</a>) Then, all the problems are over because events aren't processed in parallel anymore and you have only one excecution stream. For most applications, that will do... several events libraries act this way and are already very efficient. But, although you don't block when processing events (and you must not!), if your event's processings are still consuming significative CPU time (eg. cache search for each event, huge I/O's, etc), PEAK task capabilities of processing multiple events in the same time has shown global improvement for the application.</dd></dl>
<dl compact><dt><b></b></dt><dd>Note: Synchronization between several PEAK's tasks are not yet available, as you can only have one task in the current version of the library. </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="ga0" doxytag="task_sync::peak_task_lock" ></a>
typedef __peak_task_lock *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga0">peak_task_lock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque task lock type. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="ga1" doxytag="task_sync::peak_task_mutex" ></a>
typedef __peak_task_mutex *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque task mutex type. <br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga2">peak_task_exclusivity</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire task execution exclusivity.  <a href="#ga2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__task__sync.html#ga0">peak_task_lock</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga3">peak_task_lock_create</a> (<a class="el" href="group__task__common.html#ga0">peak_task</a> task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a task's lock.  <a href="#ga3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga4">peak_task_lock_acquire</a> (<a class="el" href="group__task__sync.html#ga0">peak_task_lock</a> lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire a task's lock.  <a href="#ga4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga5">peak_task_lock_try</a> (<a class="el" href="group__task__sync.html#ga0">peak_task_lock</a> lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to acquire a task's lock.  <a href="#ga5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga6">peak_task_lock_release</a> (<a class="el" href="group__task__sync.html#ga0">peak_task_lock</a> lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a task's lock.  <a href="#ga6"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga7">peak_task_lock_handoff</a> (<a class="el" href="group__task__sync.html#ga0">peak_task_lock</a> lock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hand-off a task's lock.  <a href="#ga7"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga8">peak_task_mutex_create</a> (<a class="el" href="group__task__common.html#ga0">peak_task</a> task)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a task's mutex.  <a href="#ga8"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga9">peak_task_mutex_lock</a> (<a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a> mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock a task's mutex.  <a href="#ga9"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga10">peak_task_mutex_trylock</a> (<a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a> mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock a task's mutex.  <a href="#ga10"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="group__task__sync.html#ga11">peak_task_mutex_unlock</a> (<a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a> mutex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock a task's mutex.  <a href="#ga11"></a><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga2" doxytag="task.h::peak_task_exclusivity" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void peak_task_exclusivity </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire task execution exclusivity. 
<p>
This function acquires temporary exclusive task execution among all task's threads. It's usually called at the beginning of an event-callback to avoid conflicts with other events (as they might be processed in parallel), when you deal with a lot of shared data in the callback.<br>
 This function does nothing if the task has only one running thread, and slow down event processing otherwise. Exclusive execution is garanteed in the whole callback, in fact, it's garanteed until the next event or timer on the current task.<br>
 Note there is no parameter at all: you can only acquire exclusive execution on the current task.     </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="task.h::peak_task_lock_acquire" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void peak_task_lock_acquire </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__sync.html#ga0">peak_task_lock</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Acquire a task's lock. 
<p>
This function acquires a task's lock. If the lock is already owned by another thread of the task, then the calling thread will block. However, this function does nothing if the task has only one thread. If a deadlock is detected, the program will abort, so be careful with recursions! Possibly, use <a class="el" href="group__task__sync.html#ga5">peak_task_lock_try()</a>.<br>
 Note that you can only acquire a lock for the current task.     </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="task.h::peak_task_lock_create" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__task__sync.html#ga0">peak_task_lock</a> peak_task_lock_create </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__common.html#ga0">peak_task</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a task's lock. 
<p>
Allow you to lock threads in order to create critical regions, for example, within a task, with <a class="el" href="group__task__sync.html#ga4">peak_task_lock_acquire()</a>, <a class="el" href="group__task__sync.html#ga6">peak_task_lock_release()</a>, etc. Like other PEAK's objets, you can destroy a lock with <a class="el" href="group__alloc.html#ga7">peak_release()</a>. THEY ARE ACTIVE LOCKS FOR SMALL DATA STRUCTURES PROTECTION ONLY. If you think you will have almost no collision for a critical region, they are for you.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The task to associated with the lock (usually <a class="el" href="group__task__common.html#ga8">peak_task_self()</a>).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A new <code>peak_task_lock</code> reference. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="task.h::peak_task_lock_handoff" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void peak_task_lock_handoff </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__sync.html#ga0">peak_task_lock</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Hand-off a task's lock. 
<p>
To assume the lock's ownership, this function passes a task's lock from the calling thread to another thread of the task. The lock must be already owned by the calling thread. If no other thread is waiting for acquiring the lock, this call will block until it happens. If the task has only one running thread, this function will abort the program (because if you use this function, you want a special synchronization behaviour that can't happen with one thread only). See <a class="el" href="group__task__common.html#ga17">peak_task_set_info()</a> to properly configure your task.<br>
 Note that you can only hand-off a lock for the current task.     </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="task.h::peak_task_lock_release" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void peak_task_lock_release </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__sync.html#ga0">peak_task_lock</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Release a task's lock. 
<p>
This function releases a task's lock, so one another thread of the task can acquire it. However, this function does nothing if the task has only one thread.<br>
 Note that you can only release a lock for the current task.     </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="task.h::peak_task_lock_try" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int peak_task_lock_try </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__sync.html#ga0">peak_task_lock</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>lock</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Try to acquire a task's lock. 
<p>
This function attempts to acquire a task's lock without blocking. The return value indicatees whether the lock was acquired. This function does nothing if the task has only one running thread and in that case always succeeds.<br>
 Note that you can only try a lock for the current task.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>1</em>&nbsp;</td><td>if the lock was acquired </td></tr>
    <tr><td valign=top><em>0</em>&nbsp;</td><td>if the lock is already owned (busy) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8" doxytag="task.h::peak_task_mutex_create" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a> peak_task_mutex_create </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__common.html#ga0">peak_task</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>task</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a task's mutex. 
<p>
Allow you to create critical regions within a task, with <a class="el" href="group__task__sync.html#ga9">peak_task_mutex_lock()</a>, <a class="el" href="group__task__sync.html#ga11">peak_task_mutex_unlock()</a>, etc. Like other PEAK's objets, you can destroy a mutex with <a class="el" href="group__alloc.html#ga7">peak_release()</a>. Task's mutex are more suitable to create large mutual exclusion regions than task's locks are, as they shouldn't spinlock much. However, if you need to protect basic and small data structures, it might be lighter to use task's locks (eg. for a simple operation like "object-&gt;i++;" ).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>task</em>&nbsp;</td><td>The task to associated with the mutex (usually <a class="el" href="group__task__common.html#ga8">peak_task_self()</a>).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A new <code>peak_task_mutex</code> reference. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="task.h::peak_task_mutex_lock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void peak_task_mutex_lock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock a task's mutex. 
<p>
This function locks a task's <em>mutex</em>. If the mutex is already locked then the calling thread will block until the mutex becomes available. However, this function does nothing if the task has only one thread. If a deadlock is detected, the program will abort. Possibly, use <a class="el" href="group__task__sync.html#ga10">peak_task_mutex_trylock()</a>.<br>
 Note that you can only lock a mutex for the current task.     </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="task.h::peak_task_mutex_trylock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void peak_task_mutex_trylock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Try to lock a task's mutex. 
<p>
This function locks a task's <em>mutex</em>. If the mutex is already locked then the calling thread will block until the mutex becomes available. However, this function does nothing if the task has only one thread.<br>
 Note that you can only lock a mutex for the current task.     </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="task.h::peak_task_mutex_unlock" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void peak_task_mutex_unlock </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__task__sync.html#ga1">peak_task_mutex</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mutex</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock a task's mutex. 
<p>
This function unlocks a task's <em>mutex</em>. However, this function does nothing if the task has only one thread.<br>
 Note that you can only unlock a mutex for the current task.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jan 17 21:41:54 2004 for the PEAK Library by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0" > 
</a></small>&nbsp; &nbsp; <a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=98146&amp;type=1" width="88" height="31" align="middle" border="0" alt="SourceForge.net Logo" /></a></address>
</body>
</html>

